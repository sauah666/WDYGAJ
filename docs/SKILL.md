# SKILL: Architectural Modeling

## Назначение навыка

Этот навык определяет, как превращать намерение в управляемую систему моделей, так чтобы AI-агенты могли:

* строить систему по частям, не разрушая целое
* проверять соответствие реализации замыслу
* не наращивать неконтролируемую сложность

Навык не про архитектурные стили.
Навык про управление системой через инварианты.

Цель: обеспечить концептуальную целостность, управляемость и проверяемость системы независимо от скорости исполнения (человек или AI).

---

## Базовая аксиома

Любая сложная система управляется через:

1. границу
2. функции
3. ответственность
4. обратную связь
5. инварианты

Если отсутствует хотя бы один пункт — система деградирует.

---

## Инвариант 1 — Граница системы и допущения среды

### Определение

Граница системы — это формальное разделение:

* что является системой
* что является внешней средой
* какие взаимодействия допустимы между ними

### Обязательные действия

Архитектор обязан явно зафиксировать:

* что система делает
* что система НЕ делает
* какие внешние акторы существуют
* через какие интерфейсы разрешено взаимодействие

### Правило

Каждый артефакт реализации должен однозначно классифицироваться как:

* внутри системы
* снаружи системы

Если это невозможно — граница размыта.

### Проверка

Любая интеграция должна иметь:

* определённый контракт
* согласованные форматы
* согласованные единицы

Несогласованность на границе считается архитектурной ошибкой.

Архитектор также обязан явно фиксировать допущения о внешней среде (assumptions):

* что считается стабильным
* что может меняться
* какие внешние сбои допустимы

Неявные допущения считаются скрытыми рисками.

---

## Инвариант 2 — Функциональная декомпозиция и трассируемость

### Определение

Система описывается через функции, а не через компоненты.

Функция = преобразование входа в выход с измеримым результатом.

### Обязательные действия

Архитектор обязан:

* составить список всех функций системы
* декомпозировать их до уровня проверяемости
* для каждой функции указать:

  * вход
  * выход
  * критерий готовности

### Правило

Ни один компонент не создаётся без привязки к функции.

### Проверка

Если элемент реализации не обслуживает ни одной функции — это архитектурный мусор.

Каждая функция обязана быть связана:

* с бизнес-потребностью
* с реализацией
* с проверкой

Если связь потеряна — функция считается неподконтрольной.

---

## Инвариант 3 — Назначение ответственности и доменные границы

### Определение

Каждая функция должна иметь ровно одного владельца.

Владелец = компонент / модуль / агент, отвечающий за реализацию.

### Обязательные действия

Архитектор обязан:

* построить карту ответственности
* явно назначить владельца каждой функции
* исключить пересечение зон ответственности
* разделить систему на смысловые (доменные) контексты

Каждый контекст:

* имеет собственную модель
* собственный словарь терминов
* собственную ответственность

Контексты взаимодействуют только через явно определённые соглашения.

Это предотвращает размывание понятий и логики.

### Правило

Одна ответственность — одно место.

### Проверка

Если изменение одной функции требует модификации нескольких независимых частей — ответственность размыта.

---

## Инвариант 4 — Петли обратной связи, наблюдаемость и V-модель

### Определение

Любая система обязана иметь замкнутые циклы:

наблюдение → сравнение с целью → корректировка.

### Обязательные действия

Архитектор обязан задать:

* какие сигналы считаются доказательством корректности
* какие метрики наблюдаются
* какие условия запускают корректировку
* какие события считаются аномалиями

Система должна быть наблюдаемой: ключевые состояния и переходы должны быть видимы архитектору.

Отсутствие наблюдаемости считается архитектурной слепотой.

### В разработке с AI

Каждый цикл обязан иметь форму:

EXECUTE → VERIFY → ADJUST

Без VERIFY цикл считается незамкнутым.

### Правило

Ни одно действие не считается завершённым без проверяемого результата.

### Проверка

Если результат нельзя проверить без “веры на слово” — обратная связь отсутствует.

Каждое проектное решение должно иметь парную проверку:

* граница ↔ системная валидация
* функции ↔ функциональные проверки
* компоненты ↔ интеграционные проверки

Проектирование без заранее спланированной проверки запрещено.

---

## Инвариант 5 — Архитектурные инварианты, качества системы и контроль абстракций

### Целевые качества системы

Архитектор обязан явно задать целевые качества системы (quality attributes):

* надёжность
* предсказуемость
* расширяемость
* управляемость

Эти качества рассматриваются как архитектурные ограничения, а не как побочные свойства.

### Определение

Инварианты — это свойства системы, которые не допускается нарушать при любых изменениях.

Это фундаментальные ограничения архитектуры.

### Примеры формата инвариантов

* для каждого типа данных существует ровно один владелец (единственный источник истины)

* остальные компоненты имеют право только читать или кэшировать

* дублирование владения данными запрещено

* ответственности не смешиваются

* внутреннее не зависит от внешнего

* все внешние интеграции проходят через единый контракт

* единицы данных согласованы

* бизнес-логика изолирована от инфраструктуры

### Обязательные действия

Архитектор обязан контролировать уровни абстракции:

* каждый слой имеет чёткое назначение
* более высокие уровни не зависят от более низких
* детали не протекают вверх

Размытие уровней абстракции считается архитектурной деградацией.

Архитектор обязан:

* сформировать список из 5–12 инвариантов
* включать их в каждую задачу агенту
* требовать доказательства соблюдения

### Правило

Если изменение нарушает инвариант — агент обязан остановиться и предложить альтернативу.

---

## Минимальный операционный набор моделей и архитектурные решения

Архитектор обязан всегда поддерживать следующие артефакты:

### 1. Граница и контекст

Текстовое описание:

* что система делает
* что вне системы
* внешние акторы
* допустимые интерфейсы

### 2. Функциональная карта

Список функций с:

* входами
* выходами
* критериями готовности

### 3. Карта ответственности

Соответствие:

функция → владелец

без пересечений.

### 4. Петля проверки

Описание:

* как проверяется каждая функция
* какие сигналы используются
* какие условия стопа

### 5. Инварианты

Короткий список архитектурных запретов и обязательств.

### 6. Архитектурные решения (ADR)

Для каждого существенного выбора архитектор обязан зафиксировать:

* контекст решения
* альтернативы
* выбранный вариант
* причину выбора
* какие инварианты это решение поддерживает

Решения без фиксации считаются потерянными.

Каждое ADR должно быть трассируемо к:

* функции
* доменному контексту
* поддерживаемым инвариантам

Если связь потеряна — решение считается архитектурно мёртвым.

---

## Использование навыка с AI-агентами и управление абстракцией

### Архитектор всегда действует сверху вниз

1. задаёт границу
2. задаёт функции
3. распределяет ответственность
4. задаёт обратную связь
5. фиксирует инварианты

Только после этого разрешается реализация.

---

### Формат задания агенту

Каждая задача агенту также обязана явно указывать уровень абстракции:

* системный
* функциональный
* компонентный

Смешение уровней в одной задаче запрещено.

Каждая задача агенту обязана содержать:

* границу
* функции
* ответственность
* требования проверки
* список инвариантов

---

### Верификация результата агента

Архитектор проверяет:

* соблюдение границы
* покрытие всех функций
* корректность распределения ответственности
* наличие проверок
* отсутствие нарушений инвариантов

---

## Контроль роста сложности, архитектурные компромиссы и условия отказа

Архитектор обязан:

* запрещать неиспользуемые абстракции
* предотвращать смешение ответственностей
* регулярно пересматривать границы
* разделять перегруженные модули
* фиксировать архитектурные решения письменно

Любое увеличение сложности должно быть осознанным.

Архитектор обязан явно фиксировать архитектурные компромиссы:

* скорость vs надёжность
* простота vs гибкость
* централизация vs распределённость

Неявные компромиссы считаются архитектурной ошибкой.

### Условия архитектурного отказа (Fail Conditions)

Система или агент считаются архитектурно несостоятельными, если выполняется хотя бы одно:

* нарушен любой инвариант
* потеряна трассируемость функций
* размыты доменные границы
* отсутствует проверяемая обратная связь
* смешаны уровни абстракции
* невозможно указать владельца функции

При наступлении любого условия архитектор обязан остановить развитие системы и вернуть её в контролируемое состояние.

---

## Роль архитектора и концептуальная целостность

Архитектор — это не реализатор.

Архитектор — хранитель:

* границы
* структуры
* ответственности
* обратной связи
* инвариантов

Он обеспечивает концептуальную целостность системы.

Система обязана следовать единой архитектурной философии.

Архитектор является единственным хранителем этой философии.

Любые изменения проверяются на соответствие исходной логике системы.

Если разные части начинают жить по разным правилам — архитектура считается нарушенной.

---

## Критерий владения навыком

Навык считается освоенным, если архитектор способен:

* удерживать концептуальную целостность системы
* обеспечивать единый источник истины для данных
* разделять систему на смысловые контексты
* сохранять трассируемость от намерения до проверки
* проектировать вместе с проверкой (V-подход)
* осознанно управлять архитектурными компромиссами

А также:

* формально моделировать систему без кода
* управлять AI через архитектурные ограничения
* предотвращать деградацию структуры
* обнаруживать архитектурные ошибки до реализации
* сохранять целостность при росте системы
